import "./chunk-OL3AADLO.js";

// node_modules/fast-equals/dist/fast-equals.esm.js
function createDefaultIsNestedEqual(comparator) {
  return function isEqual(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, meta) {
    return comparator(a, b, meta);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular(a, b, isEqual, cache) {
    if (!a || !b || typeof a !== "object" || typeof b !== "object") {
      return areItemsEqual(a, b, isEqual, cache);
    }
    var cachedA = cache.get(a);
    var cachedB = cache.get(b);
    if (cachedA && cachedB) {
      return cachedA === b && cachedB === a;
    }
    cache.set(a, b);
    cache.set(b, a);
    var result = areItemsEqual(a, b, isEqual, cache);
    cache.delete(a);
    cache.delete(b);
    return result;
  };
}
function merge(a, b) {
  var merged = {};
  for (var key in a) {
    merged[key] = a[key];
  }
  for (var key in b) {
    merged[key] = b[key];
  }
  return merged;
}
function isPlainObject(value) {
  return value.constructor === Object || value.constructor == null;
}
function isPromiseLike(value) {
  return typeof value.then === "function";
}
function sameValueZeroEqual(a, b) {
  return a === b || a !== a && b !== b;
}
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATE_TAG = "[object Date]";
var REG_EXP_TAG = "[object RegExp]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var toString = Object.prototype.toString;
function createComparator(_a) {
  var areArraysEqual2 = _a.areArraysEqual, areDatesEqual2 = _a.areDatesEqual, areMapsEqual2 = _a.areMapsEqual, areObjectsEqual2 = _a.areObjectsEqual, areRegExpsEqual2 = _a.areRegExpsEqual, areSetsEqual2 = _a.areSetsEqual, createIsNestedEqual = _a.createIsNestedEqual;
  var isEqual = createIsNestedEqual(comparator);
  function comparator(a, b, meta) {
    if (a === b) {
      return true;
    }
    if (!a || !b || typeof a !== "object" || typeof b !== "object") {
      return a !== a && b !== b;
    }
    if (isPlainObject(a) && isPlainObject(b)) {
      return areObjectsEqual2(a, b, isEqual, meta);
    }
    var aArray = Array.isArray(a);
    var bArray = Array.isArray(b);
    if (aArray || bArray) {
      return aArray === bArray && areArraysEqual2(a, b, isEqual, meta);
    }
    var aTag = toString.call(a);
    if (aTag !== toString.call(b)) {
      return false;
    }
    if (aTag === DATE_TAG) {
      return areDatesEqual2(a, b, isEqual, meta);
    }
    if (aTag === REG_EXP_TAG) {
      return areRegExpsEqual2(a, b, isEqual, meta);
    }
    if (aTag === MAP_TAG) {
      return areMapsEqual2(a, b, isEqual, meta);
    }
    if (aTag === SET_TAG) {
      return areSetsEqual2(a, b, isEqual, meta);
    }
    if (aTag === OBJECT_TAG || aTag === ARGUMENTS_TAG) {
      return isPromiseLike(a) || isPromiseLike(b) ? false : areObjectsEqual2(a, b, isEqual, meta);
    }
    if (aTag === BOOLEAN_TAG || aTag === NUMBER_TAG || aTag === STRING_TAG) {
      return sameValueZeroEqual(a.valueOf(), b.valueOf());
    }
    return false;
  }
  return comparator;
}
function areArraysEqual(a, b, isEqual, meta) {
  var index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!isEqual(a[index], b[index], index, index, a, b, meta)) {
      return false;
    }
  }
  return true;
}
var areArraysEqualCircular = createIsCircular(areArraysEqual);
function areDatesEqual(a, b) {
  return sameValueZeroEqual(a.valueOf(), b.valueOf());
}
function areMapsEqual(a, b, isEqual, meta) {
  var isValueEqual = a.size === b.size;
  if (!isValueEqual) {
    return false;
  }
  if (!a.size) {
    return true;
  }
  var matchedIndices = {};
  var indexA = 0;
  a.forEach(function(aValue, aKey) {
    if (!isValueEqual) {
      return;
    }
    var hasMatch = false;
    var matchIndexB = 0;
    b.forEach(function(bValue, bKey) {
      if (!hasMatch && !matchedIndices[matchIndexB] && (hasMatch = isEqual(aKey, bKey, indexA, matchIndexB, a, b, meta) && isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {
        matchedIndices[matchIndexB] = true;
      }
      matchIndexB++;
    });
    indexA++;
    isValueEqual = hasMatch;
  });
  return isValueEqual;
}
var areMapsEqualCircular = createIsCircular(areMapsEqual);
var OWNER = "_owner";
var hasOwnProperty = Object.prototype.hasOwnProperty;
function areObjectsEqual(a, b, isEqual, meta) {
  var keysA = Object.keys(a);
  var index = keysA.length;
  if (Object.keys(b).length !== index) {
    return false;
  }
  var key;
  while (index-- > 0) {
    key = keysA[index];
    if (key === OWNER) {
      var reactElementA = !!a.$$typeof;
      var reactElementB = !!b.$$typeof;
      if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {
        return false;
      }
    }
    if (!hasOwnProperty.call(b, key) || !isEqual(a[key], b[key], key, key, a, b, meta)) {
      return false;
    }
  }
  return true;
}
var areObjectsEqualCircular = createIsCircular(areObjectsEqual);
function areRegExpsEqual(a, b) {
  return a.source === b.source && a.flags === b.flags;
}
function areSetsEqual(a, b, isEqual, meta) {
  var isValueEqual = a.size === b.size;
  if (!isValueEqual) {
    return false;
  }
  if (!a.size) {
    return true;
  }
  var matchedIndices = {};
  a.forEach(function(aValue, aKey) {
    if (!isValueEqual) {
      return;
    }
    var hasMatch = false;
    var matchIndex = 0;
    b.forEach(function(bValue, bKey) {
      if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = isEqual(aValue, bValue, aKey, bKey, a, b, meta))) {
        matchedIndices[matchIndex] = true;
      }
      matchIndex++;
    });
    isValueEqual = hasMatch;
  });
  return isValueEqual;
}
var areSetsEqualCircular = createIsCircular(areSetsEqual);
var DEFAULT_CONFIG = Object.freeze({
  areArraysEqual,
  areDatesEqual,
  areMapsEqual,
  areObjectsEqual,
  areRegExpsEqual,
  areSetsEqual,
  createIsNestedEqual: createDefaultIsNestedEqual
});
var DEFAULT_CIRCULAR_CONFIG = Object.freeze({
  areArraysEqual: areArraysEqualCircular,
  areDatesEqual,
  areMapsEqual: areMapsEqualCircular,
  areObjectsEqual: areObjectsEqualCircular,
  areRegExpsEqual,
  areSetsEqual: areSetsEqualCircular,
  createIsNestedEqual: createDefaultIsNestedEqual
});
var isDeepEqual = createComparator(DEFAULT_CONFIG);
function deepEqual(a, b) {
  return isDeepEqual(a, b, void 0);
}
var isShallowEqual = createComparator(merge(DEFAULT_CONFIG, { createIsNestedEqual: function() {
  return sameValueZeroEqual;
} }));
function shallowEqual(a, b) {
  return isShallowEqual(a, b, void 0);
}
var isCircularDeepEqual = createComparator(DEFAULT_CIRCULAR_CONFIG);
function circularDeepEqual(a, b) {
  return isCircularDeepEqual(a, b, /* @__PURE__ */ new WeakMap());
}
var isCircularShallowEqual = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, {
  createIsNestedEqual: function() {
    return sameValueZeroEqual;
  }
}));
function circularShallowEqual(a, b) {
  return isCircularShallowEqual(a, b, /* @__PURE__ */ new WeakMap());
}
function createCustomEqual(getComparatorOptions) {
  return createComparator(merge(DEFAULT_CONFIG, getComparatorOptions(DEFAULT_CONFIG)));
}
function createCustomCircularEqual(getComparatorOptions) {
  var comparator = createComparator(merge(DEFAULT_CIRCULAR_CONFIG, getComparatorOptions(DEFAULT_CIRCULAR_CONFIG)));
  return function(a, b, meta) {
    if (meta === void 0) {
      meta = /* @__PURE__ */ new WeakMap();
    }
    return comparator(a, b, meta);
  };
}
export {
  circularDeepEqual,
  circularShallowEqual,
  createCustomCircularEqual,
  createCustomEqual,
  deepEqual,
  sameValueZeroEqual,
  shallowEqual
};
//# sourceMappingURL=fast-equals.js.map
